Reverse Engineering Cheatsheet

Thanks to https://tryhackme.com/room/introtox8664 for the intro to asm!

| Intel Code                    | AT&T Code                         |
|-------------------------------|-----------------------------------|
| mov eax,1                     | movl $1,%eax                      |
| mov ebx,0ffh                  | movl $0xff,%ebx                   |
| int 80h                       | int $0x80                         |
| mov ebx, eax                  | movl %eax, %ebx                   |
| mov eax,\[ecx\]               | movl \(%ecx\),%eax                |
| mov eax,\[ebx\+3\]            | movl 3\(%ebx\),%eax               |
| mov eax,\[ebx\+20h\]          | movl 0x20\(%ebx\),%eax            |
| add eax,\[ebx\+ecx\*2h\]      | addl \(%ebx,%ecx,0x2\),%eax       |
| lea eax,\[ebx\+ecx\]          | leal \(%ebx,%ecx\),%eax           |
| sub eax,\[ebx\+ecx\*4h\-20h\] | subl \-0x20\(%ebx,%ecx,0x4\),%eax |


| r2 command                               | what it does                                            |
|------------------------------------------|---------------------------------------------------------|
| R2 \-d FILE                              | Opens file                                              |
| aaa                                      | Analyze everything                                      |
| e asm\.syntax=att OR e asm\.syntax=intel | Sets format: see below for differences                  |
| ?                                        | Help                                                    |
| afl                                      | List functions                                          |
| pdf @main                                | print disassembly function \(in this case main\)        |
| db 0x58923789ab2                         | Breakpoint at hex                                       |
| px @REFERENCE                            | see value at that hex location \(technically hex dump\) |
| dc                                       | run program to breakpoint                               |
| ds                                       | run one line                                            |

| 64 bit | 32 bit |
|--------|--------|
| %rax   | %eax   |
| %rbx   | %ebx   |
| %rcx   | %ecx   |
| %rdx   | %edx   |
| %rsi   | %esi   |
| %rdi   | %edi   |
| %rsp   | %esp   |
| %rbp   | %ebp   |
| %r8    | %r8d   |
| %r9    | %r9d   |
| %r10   | %r10d  |
| %r11   | %r11d  |
| %r12   | %r12d  |
| %r13   | %r13d  |
| %r14   | %r14d  |
| %r15   | %r15d  |
When debugging, most of the time 64 bit = 32 bit register

### Following info is on ATT syntax

`movq source, destination`
This involves:
- Transferring constants (which are prefixed using the $ operator) e.g. movq $3 rax would move the constant 3 to the register
- Transferring values from a register e.g. movq %rax %rbx which involves moving value from rax to rbx
- Transferring values from memory which is shown by putting registers inside brackets e.g. `movq %rax (%rbx)` which means move value stored in %rax to memory location represented by %rbx.

The last letter of the mov instruction represents the size of the data:


| Intel Data Type  | Suffix | Size\(bytes\) |
|------------------|--------|---------------|
| Byte             | b      | 1             |
| Word             | w      | 2             |
| Double Word      | l      | 4             |
| Quad Word        | q      | 8             |
| Quad Word        | q      | 8             |
| Single Precision | s      | 4             |
| Double Precision | l      | 8             |



When dealing with memory manipulation using registers, there are other cases to be considered:
- `(Rb, Ri) = MemoryLocation[Rb + Ri]`
- `D(Rb, Ri) = MemoryLocation[Rb + Ri + D]`
- `(Rb, Ri, S) = MemoryLocation(Rb + S * Ri]`
- `D(Rb, Ri, S) = MemoryLocation[Rb + S * Ri + D]`


Some other important instructions are:
- `leaq source, destination`: this instruction sets destination to the address denoted by the expression in source
- `addq source, destination`: destination = destination + source
- `subq source, destination`: destination = destination - source
- `imulq source, destination`: destination = destination * source
- `salq source, destination`: destination = destination << source where << is the left bit shifting operator
- `sarq source, destination`: destination = destination >> source where >> is the right bit shifting operator
- `xorq source, destination`: destination = destination XOR source
- `andq source, destination`: destination = destination & source
- `orq source, destination`: destination = destination | source


The general format of an if statement is 
```
if(condition){
    do-stuff-here
} else if(condition) {
    do-stuff-here
} else {
    do-stuff-here
}
```

If-statements use 3 important instructions in assembly:
- `cmpq b, a`: it is like computing a-b without changing anything
- `testq b, a`: it is like computing bitwise a&b without changing anything
	- `test EAX,EAX` // Test if zero, then set Zero Flag to 1
	- `je some_address` // jumps if previous was zero
		- Same as:
		- `if(eax == 0) { goto address }`

Jump instructions are used to transfer control to different instructions, and there are different types of jumps: 


| Jump Type | Description                 |
|-----------|-----------------------------|
| jmp       | Unconditional \(just jump\) |
| je        | Equal/Zero                  |
| jne       | Not Equal/Not Zero          |
| js        | Negative                    |
| jns       | Nonnegative                 |
| jg        | Greater                     |
| jge       | Greater or Equal            |
| jl        | Less                        |
| jle       | Less or Equal               |
| ja        | Above\(unsigned\)           |
| jb        | Below\(unsigned\)           |

	
The last 2 values of the table refer to unsigned integers. Unsigned integers cannot be negative while signed integers represent both positive and negative values. Since the computer needs to differentiate between them, it uses different methods to interpret these values. For signed integers, it uses something called the twoâ€™s complement representation and for unsigned integers it uses normal binary calculations. 

