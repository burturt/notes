7. Scripting with Bash

### Working with ping
`ping 1.1.1.1 -c 1`
``` PING 1.1.1.1 (1.1.1.1) 56(84) bytes of data.
64 bytes from 1.1.1.1: icmp_seq=1 ttl=128 time=60.3 ms

--- 1.1.1.1 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 60.326/60.326/60.326/0.000 ms
```
- `ping 1.1.1.1 -c 1 | grep "64 bytes"`
Pings and only gets the line with the ip address
- `ping 1.1.1.1 -c 1 | grep "64 bytes" | cut -d " " -f 4`
Gets ip address, but leaves `:` at end
	- cut format: -d = deliminator to cut up string into "fields", -f = field number from deliminator
- `ping 1.1.1.1 -c 1 | grep "64 bytes" | cut -d " " -f 4 | tr -d ":"`
Only gets ip address after "trimming" colon
### One-linter loop
`for ip in $(cat iplist.txt); do nmap -sS -p 80 -T4 $ip & done`
- iplist is a newline delimited list
- nmap is the command to run with every item in the list stored as $ip variable
### Creating a script:
- Start with `#!/bin/bash` in file
- Put commands in as if you ran as commands in terminal
- Name as NAME.sh
- `chmod +x SCRIPT`
## Example script:

[ipsweep.sh](../../_resources/ab847edbd34442afaeebccd9fcb79430.sh)
```bash
#!/bin/bash

for ip in `seq 1 254`; do
ping -c 1 $1.$ip | grep "64 bytes" | cut -d " " -f 4 | tr -d ":" &
# & sign means it does not wait for command to finish, otherwise use semicolon.
done
```
`for VAR in 1, 2, 3, ..., 253, 254`; do
$1 = user input. so `./ipsweep.sh 192.168.1` replaces 192.168.1 as $1.
#### Improved:
```bash
#!/bin/bash
if [ "$1" == "" ]
then
echo "You forgot an IP address!"
echo "Syntax: ./ipsweep.sh 192.168.1"

else
for ip in `seq 1 254`; do
ping -c 1 $1.$ip | grep "64 bytes" | cut -d " " -f 4 | tr -d ":" &
done
fi # End of else loop
```